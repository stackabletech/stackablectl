---
apiVersion: opa.stackable.tech/v1alpha1
kind: OpaCluster
metadata:
  name: opa
spec:
  image:
    productVersion: "0.51.0"
    stackableVersion: "23.7.0"
  clusterConfig:
    userInfo:
      backend:
        keycloak:
          hostname: keycloak.default.svc.cluster.local
          port: 8443
          clientCredentialsSecret: opa-userinfo-fetcher-client-credentials
          adminRealm: master
          userRealm: master
          tls:
            verification:
              server:
                caCert:
                  secretClass: tls
      cache:
        entryTimeToLive: 5s # For fast feedback during the demo
  servers:
    roleGroups:
      default: {}
---
apiVersion: v1
kind: Secret
metadata:
  name: opa-userinfo-fetcher-client-credentials
stringData:
  clientId: userinfo-fetcher
  clientSecret: "{{ keycloakUserinfoFetcherClientSecret }}"
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: opa-bundle-trino
  labels:
    opa.stackable.tech/bundle: "true"
data:
  trino.rego: |
    package trino

    import future.keywords.if
    import future.keywords.in

    user_info_by_name(username) := http.send({"method": "POST", "url": "http://127.0.0.1:9476/user", "body": {"username": username}, "headers": {"Content-Type": "application/json"}, "raise_error": true}).body

    is_group_member(group) if group in user_info_by_name(input.context.identity.user).groups

    # We do this because we are automating the import of the DB connections (and other things) into 
    # Superset as the local "admin" user in Superset which will not be in Keycloak.
    # Because we are using User Impersonation, this user will be used to check the database 
    # connection (read catalog).
    # This is not recommended in production.
    is_group_member(group) if input.context.identity.user == "admin"

    default allow = false

    # Admins can do anything
    allow {
      # We need to exclude ImpersonateUser, as otherwise everyone would be able to impersonate this users
      input.action.operation != "ImpersonateUser"

      is_group_member("/trino-admin")
    }
    extended[i] {
        some i
        input.action.filterResources[i]

        is_group_member("/trino-admin")
    }

    # Everyone can execute queries
    allow {
        input.action.operation in ["ExecuteQuery", "ExecuteFunction", "ReadSystemInformation"]
    }

    # Everyone can see and kill his own queries
    allow {
        input.action.operation in ["ViewQueryOwnedBy", "KillQueryOwnedBy"]
        input.action.resource.user.name == input.context.identity.user
    }

    # Superset can impersonate anyone, but not admins
    allow {
      input.action.operation == "ImpersonateUser"
      input.context.identity.principal.name == "superset" # TODO Authorize based on group membership "trino-impersonating"

      # Commented out as this made things more complicated in the demo
      # not "/trino-admin" in user_info_by_name(input.action.resource.user.name).groups
    }

    allow {
      input.action.operation == "ImpersonateUser"
      input.action.resource.user.name == input.context.identity.principal.name
    }

    # todo:
    # /trino-admin can do it all (create tables, insert data, select data)
    # /trino-readwrite can can insert/delete rows, but not create or delete tables
    # /trino-readonly can do all read operations
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: opa-bundle-druid
  labels:
    opa.stackable.tech/bundle: "true"
data:
  druid.rego: |
    package druid

    import data.bundles.opagroups.admins
    import future.keywords.in
    import future.keywords.if

    default allow = false

    allow if input.user == "druid_system"

    allow if input.user in admins
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: opagroups
  labels:
    opa.stackable.tech/bundle: "true"
data:
  data.json: |
    {
      "admins": [
        "admin",
        "alice"
      ]
    }
