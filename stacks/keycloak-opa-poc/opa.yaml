---
apiVersion: opa.stackable.tech/v1alpha1
kind: OpaCluster
metadata:
  name: opa
spec:
  image:
    productVersion: "0.51.0"
    stackableVersion: "23.7.0"
  clusterConfig:
    userInfo:
      backend:
        keycloak:
          hostname: keycloak.default.svc.cluster.local
          port: 8443
          clientCredentialsSecret: opa-userinfo-fetcher-client-credentials
          adminRealm: master
          userRealm: master
          tls:
            verification:
              server:
                caCert:
                  secretClass: tls
      cache:
        entryTimeToLive: 5s # For fast feedback during the demo
  servers:
    roleGroups:
      default: {}
---
apiVersion: v1
kind: Secret
metadata:
  name: opa-userinfo-fetcher-client-credentials
stringData:
  clientId: userinfo-fetcher
  clientSecret: "{{ keycloakUserinfoFetcherClientSecret }}"
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: opa-bundle-trino
  labels:
    opa.stackable.tech/bundle: "true"
data:
  trino.rego: |
    package trino

    import future.keywords.if
    import future.keywords.in

    user_info_by_name(username) := http.send({"method": "POST", "url": "http://127.0.0.1:9476/user", "body": {"userName": username}, "headers": {"Content-Type": "application/json"}, "raise_error": true}).body

    is_group_member(group) if group in user_info_by_name(input.context.identity.user).groups

    default allow = false

    # Admins can do anything
    allow {
      # We need to exclude ImpersonateUser, as otherwise everyone would be able to impersonate this users
      input.action.operation != "ImpersonateUser"

      is_group_member("/trino-admins")
    }
    extended[i] {
        some i
        input.action.filterResources[i]

        is_group_member("/trino-admins")
    }

    # Everyone can execute queries
    allow {
        input.action.operation in ["ExecuteQuery", "ExecuteFunction", "ReadSystemInformation"]
    }

    # Everyone can see and kill his own queries
    allow {
        input.action.operation in ["ViewQueryOwnedBy", "KillQueryOwnedBy"]
        input.action.resource.user.name == input.context.identity.user
    }

    # Superset can impersonate anyone, but not admins
    allow {
      input.action.operation == "ImpersonateUser"
      input.context.identity.principal.name == "superset"

      # Commented out as this made things more complicated in the demo
      # not "/trino-admins" in user_info_by_name(input.action.resource.user.name).groups
    }

<<<<<<< HEAD
    # allow {
    #   currentUserInfo := userInfo(input.context.identity.principal.name)
    #
    #   input.action.operation == "ImpersonateUser"
    #   input.action.resource.user.name == currentUserInfo().userName
    # }
=======
    allow {
      input.action.operation == "ImpersonateUser"
      input.action.resource.user.name == input.context.identity.principal.name
    }
>>>>>>> dc75ab8 (WIP)
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: opa-bundle-druid
  labels:
    opa.stackable.tech/bundle: "true"
data:
  druid.rego: |
    package druid

    import data.bundles.opagroups.admins
    import future.keywords.in
    import future.keywords.if

    default allow = false

    allow if input.user == "druid_system"

    allow if input.user in admins
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: opagroups
  labels:
    opa.stackable.tech/bundle: "true"
data:
  data.json: |
    {
      "admins": [
        "admin",
        "alice"
      ]
    }
